<!DOCTYPE html>
<!--
  ╔═══════════════════════════════════════════════════════════════════════════════╗
  ║  CONFIGURATION: To switch between URL formats (view=desc vs startDataset=...) ║
  ║  Go to line 124 and comment/uncomment USE_FULL_DATASET_IN_URL                ║
  ╚═══════════════════════════════════════════════════════════════════════════════╝
-->
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Insarmaps - Frame Overlay</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }
        .frame-selector {
            margin-bottom: 10px;
            padding: 10px;
            background-color: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .frame-selector label {
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }
        .frame-selector select {
            padding: 6px 12px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            flex: 1;
            max-width: 300px;
            overflow: auto;
        }
        .frame-selector select:focus {
            outline: none;
            border-color: #4a90e2;
        }
        .frame-selector select option {
            padding: 4px 8px;
        }
        .frame-selector select option:checked {
            background-color: #4a90e2;
            color: white;
        }
        .container {
            width: 100%;
            height: calc(100vh - 160px);  /* Adjusted for taller frame selector */
            max-width: 100%;
            position: relative;
        }
        .panel {
            background-color: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            transition: box-shadow 0.2s;
            /* Use visibility instead of display:none to keep iframes rendered */
            visibility: hidden;
            z-index: 0;
        }
        .panel.active {
            visibility: visible;
            z-index: 1;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.5);
        }
        .panel:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .panel-header {
            background-color: #4a90e2;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            height: 38px;
            box-sizing: border-box;
        }
        .panel-header-title {
            flex: 1;
        }
        .panel iframe {
            width: 100%;
            height: calc(100% - 38px);
            border: none;
            display: block;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading insarmaps data...</div>
    <div class="frame-selector" id="frame-selector" style="display:none;">
        <label for="frame-select">Select dataset:</label>
        <select id="frame-select"></select>
    </div>
    <div class="container" id="container"></div>
    
    <script>
        // ===== CONFIGURATION (EDIT THIS LINE TO SWITCH BETWEEN FORMATS) =====
        // To switch: comment out one line and uncomment the other
        //const USE_FULL_DATASET_IN_URL = false;  // Use short codes: view=desc/asc/vert/horz
        const USE_FULL_DATASET_IN_URL = true;   // Use full dataset names: startDataset=S1_desc_142_mintpy_...
        
        // ===== URL STATE MANAGEMENT =====
        // Map view labels to short codes for URL
        const viewCodes = {
            'Descending': 'desc',
            'Ascending': 'asc',
            'Vertical': 'vert',
            'Horizontal': 'horz'
        };
        const codeToLabel = { 'desc': 'Descending', 'asc': 'Ascending', 'vert': 'Vertical', 'horz': 'Horizontal' };

        // Get URL parameters from overlay.html's URL
        // Supports both hash format: overlay.html#/start/lat/lon/zoom?params (preferred, shareable)
        // and legacy path format: overlay.html/start/lat/lon/zoom?params (for backwards compatibility)
        // Also supports both view=desc and startDataset=<full_name> formats
        function getOverlayUrlParams() {
            let pathPart = '';
            let queryPart = '';
            
            // Check hash first (preferred format for shareability)
            if (window.location.hash) {
                const hash = window.location.hash.substring(1); // Remove leading #
                const queryIdx = hash.indexOf('?');
                if (queryIdx !== -1) {
                    pathPart = hash.substring(0, queryIdx);
                    queryPart = hash.substring(queryIdx + 1);
                } else {
                    pathPart = hash;
                }
            } else {
                // Fallback to pathname (legacy format)
                pathPart = window.location.pathname;
                queryPart = window.location.search.substring(1);
            }
            
            const pathMatch = pathPart.match(/\/start\/([^\/]+)\/([^\/]+)\/([^\/?\#]+)/);
            const params = new URLSearchParams(queryPart);
            
            return {
                view: params.get('view'),
                startDataset: params.get('startDataset'),
                lat: pathMatch ? pathMatch[1] : null,
                lon: pathMatch ? pathMatch[2] : null,
                zoom: pathMatch ? pathMatch[3] : null,
                minScale: params.get('minScale'),
                maxScale: params.get('maxScale'),
                startDate: params.get('startDate'),
                endDate: params.get('endDate'),
                pixelSize: params.get('pixelSize'),
                background: params.get('background'),
                opacity: params.get('opacity')
            };
        }

        // Update overlay.html's browser URL with current state
        // Uses hash-based URL format for shareability: overlay.html#/start/lat/lon/zoom?params
        function updateOverlayUrl(viewCodeOrDataset, mapParams, currentDataset) {
            const params = new URLSearchParams();
            
            // Choose which format to use based on configuration
            if (USE_FULL_DATASET_IN_URL && currentDataset) {
                params.set('startDataset', currentDataset);
            } else if (viewCodeOrDataset) {
                params.set('view', viewCodeOrDataset);
            }
            
            if (mapParams.minScale) params.set('minScale', mapParams.minScale);
            if (mapParams.maxScale) params.set('maxScale', mapParams.maxScale);
            if (mapParams.startDate) params.set('startDate', mapParams.startDate);
            if (mapParams.endDate) params.set('endDate', mapParams.endDate);
            if (mapParams.pixelSize) params.set('pixelSize', mapParams.pixelSize);
            if (mapParams.background) params.set('background', mapParams.background);
            if (mapParams.opacity) params.set('opacity', mapParams.opacity);
            
            // Use hash-based URL format (shareable - browser requests just overlay.html)
            let hashUrl;
            if (mapParams.lat && mapParams.lon && mapParams.zoom) {
                hashUrl = `/start/${mapParams.lat}/${mapParams.lon}/${mapParams.zoom}?${params.toString()}`;
            } else {
                hashUrl = `?${params.toString()}`;
            }
            window.history.replaceState({}, '', `#${hashUrl}`);
        }

        // Build insarmaps URL with given parameters
        function buildInsarmapsUrl(baseUrl, dataset, lat, lon, zoom, mapParams) {
            const params = new URLSearchParams();
            params.set('flyToDatasetCenter', 'false');
            params.set('startDataset', dataset);
            if (mapParams.minScale) params.set('minScale', mapParams.minScale);
            if (mapParams.maxScale) params.set('maxScale', mapParams.maxScale);
            if (mapParams.startDate) params.set('startDate', mapParams.startDate);
            if (mapParams.endDate) params.set('endDate', mapParams.endDate);
            if (mapParams.pixelSize) params.set('pixelSize', mapParams.pixelSize);
            if (mapParams.background) params.set('background', mapParams.background);
            if (mapParams.opacity) params.set('opacity', mapParams.opacity);
            params.set('_t', Date.now());
            
            return `${baseUrl}/start/${lat}/${lon}/${zoom}?${params.toString()}`;
        }

        // Extract lat/lon/zoom from an insarmaps URL
        function parseInsarmapsUrl(url) {
            try {
                const urlObj = new URL(url);
                const pathMatch = urlObj.pathname.match(/\/start\/([^\/]+)\/([^\/]+)\/([^\/]+)/);
                if (pathMatch) {
                    return { lat: pathMatch[1], lon: pathMatch[2], zoom: pathMatch[3] };
                }
            } catch (e) {}
            return null;
        }
        // ===== END URL STATE MANAGEMENT =====

        // Global state
        let iframeDatasets = new Map();  // index -> dataset name
        let iframeLabels = new Map();    // index -> label (Descending, etc.)
        let iframeSynced = new Map();    // index -> sync key (tracks if iframe has current params)
        let baseUrl = '';
        let currentViewCode = 'desc';
        let currentDataset = null;  // Current active dataset name
        let currentMapParams = {};
        let urlsList = [];
        
        // Sync control - defined early so it's available everywhere
        let lastSyncTime = 0;
        const SYNC_COOLDOWN_MS = 3000;
        
        // Generate a sync key from current params
        function getSyncKey(params) {
            return JSON.stringify({
                lat: params.lat,
                lon: params.lon,
                zoom: params.zoom,
                minScale: params.minScale,
                maxScale: params.maxScale,
                startDate: params.startDate,
                endDate: params.endDate,
                pixelSize: params.pixelSize,
                background: params.background,
                opacity: params.opacity
            });
        }

        // Parse insarmaps.log and create iframes dynamically
        fetch('insarmaps.log')
            .then(response => response.text())
            .then(data => {
                const lines = data.split('\n');
                const urls = lines
                    .map(line => line.trim())
                    .filter(line => line && (line.startsWith('http://') || line.startsWith('https://')));
                
                if (urls.length === 0) {
                    document.getElementById('loading').textContent = 'No URLs found in insarmaps.log';
                    return;
                }
                
                // Sort URLs by dataset type: desc (0), asc (1), horz (2), vert (3), others (4)
                urls.sort((a, b) => {
                    const getSortKey = (url) => {
                        try {
                            const urlObj = new URL(url);
                            const startDataset = urlObj.searchParams.get('startDataset') || '';
                            const lower = startDataset.toLowerCase();
                            if (lower.includes('desc')) return 0;
                            if (lower.includes('asc')) return 1;
                            if (lower.includes('horz')) return 2;
                            if (lower.includes('vert')) return 3;
                            return 4;
                        } catch (e) {
                            return 5;
                        }
                    };
                    return getSortKey(a) - getSortKey(b);
                });
                
                urlsList = urls;
                
                // Extract labels from URLs
                const getLabel = (url) => {
                    try {
                        const urlObj = new URL(url);
                        const startDataset = urlObj.searchParams.get('startDataset') || '';
                        const lower = startDataset.toLowerCase();
                        if (lower.includes('desc')) return 'Descending';
                        if (lower.includes('asc')) return 'Ascending';
                        if (lower.includes('vert')) return 'Vertical';
                        if (lower.includes('horz')) return 'Horizontal';
                        return startDataset || 'Dataset';
                    } catch (e) {
                        return 'Dataset';
                    }
                };
                
                // Get initial params from overlay.html URL
                const initialParams = getOverlayUrlParams();
                
                // Initialize current map params from overlay URL or first insarmaps URL
                const firstUrlCoords = parseInsarmapsUrl(urls[0]);
                currentMapParams = {
                    lat: initialParams.lat || (firstUrlCoords ? firstUrlCoords.lat : null),
                    lon: initialParams.lon || (firstUrlCoords ? firstUrlCoords.lon : null),
                    zoom: initialParams.zoom || (firstUrlCoords ? firstUrlCoords.zoom : null),
                    minScale: initialParams.minScale,
                    maxScale: initialParams.maxScale,
                    startDate: initialParams.startDate,
                    endDate: initialParams.endDate,
                    pixelSize: initialParams.pixelSize,
                    background: initialParams.background,
                    opacity: initialParams.opacity
                };
                
                // Create panels for each URL
                const container = document.getElementById('container');
                const frameSelect = document.getElementById('frame-select');
                const frameSelector = document.getElementById('frame-selector');
                
                // Determine initial active panel based on URL view param
                let initialActiveIndex = 0;
                
                urls.forEach((url, index) => {
                    let dataset = null;  // Declare outside try block so it's accessible below
                    try {
                        const urlObj = new URL(url);
                        dataset = urlObj.searchParams.get('startDataset');
                        iframeDatasets.set(index, dataset);
                        
                        // Extract base URL from first URL
                        if (!baseUrl) {
                            baseUrl = urlObj.origin;
                        }
                    } catch (e) {
                        console.warn('Could not parse URL:', url);
                    }
                    
                    const label = getLabel(url);
                    iframeLabels.set(index, label);
                    const labelCode = viewCodes[label] || label.toLowerCase();
                    
                    // Check if this should be the active panel based on URL param
                    // Support both view=desc and startDataset=<full_name>
                    if (initialParams.startDataset && dataset === initialParams.startDataset) {
                        initialActiveIndex = index;
                        currentViewCode = labelCode;
                        currentDataset = dataset;
                    } else if (initialParams.view && labelCode === initialParams.view) {
                        initialActiveIndex = index;
                        currentViewCode = labelCode;
                        currentDataset = dataset;
                    }
                    
                    // Add option to dropdown
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = label;
                    frameSelect.appendChild(option);
                });
                
                // Set default view code and dataset if not specified in URL
                if (!initialParams.view && !initialParams.startDataset) {
                    const firstLabel = iframeLabels.get(0);
                    currentViewCode = viewCodes[firstLabel] || 'desc';
                    currentDataset = iframeDatasets.get(0);
                } else if (!currentDataset) {
                    currentDataset = iframeDatasets.get(initialActiveIndex);
                }
                
                // Create panels with potentially modified URLs
                urls.forEach((url, index) => {
                    // Create panel
                    const panel = document.createElement('div');
                    panel.className = 'panel';
                    panel.id = `panel${index}`;
                    if (index === initialActiveIndex) panel.classList.add('active');
                    
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'panel-header';
                    const title = document.createElement('span');
                    title.className = 'panel-header-title';
                    title.textContent = iframeLabels.get(index);
                    header.appendChild(title);
                    
                    // Build iframe URL - use overlay params if available
                    let iframeSrc = url;
                    const dataset = iframeDatasets.get(index);
                    if (currentMapParams.lat && currentMapParams.lon && currentMapParams.zoom && dataset) {
                        iframeSrc = buildInsarmapsUrl(
                            baseUrl, 
                            dataset, 
                            currentMapParams.lat, 
                            currentMapParams.lon, 
                            currentMapParams.zoom, 
                            currentMapParams
                        );
                    } else {
                        iframeSrc = url + (url.includes('?') ? '&' : '?') + '_t=' + Date.now();
                    }
                    
                    // Create iframe
                    const iframe = document.createElement('iframe');
                    iframe.id = `iframe${index}`;
                    iframe.title = iframeLabels.get(index);
                    iframe.src = iframeSrc;
                    iframe.setAttribute('allowfullscreen', '');
                    
                    // Mark iframe as synced with initial params
                    iframeSynced.set(index, getSyncKey(currentMapParams));
                    
                    panel.appendChild(header);
                    panel.appendChild(iframe);
                    container.appendChild(panel);
                });
                
                // Show selector and hide loading
                frameSelector.style.display = 'flex';
                document.getElementById('loading').style.display = 'none';
                
                // Set select size to show all options (max 6 to avoid huge list)
                const numOptions = frameSelect.options.length;
                frameSelect.size = Math.min(numOptions, 6);
                
                // Set initial dropdown selection
                frameSelect.value = initialActiveIndex.toString();
                
                // Update overlay URL with initial state
                updateOverlayUrl(currentViewCode, currentMapParams, currentDataset);
                
                // Frame selector functionality - update URL and reload iframe when dataset changes
                frameSelect.addEventListener('change', (e) => {
                    const selectedIndex = parseInt(e.target.value);
                    document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
                    const selectedPanel = document.getElementById(`panel${selectedIndex}`);
                    if (selectedPanel) selectedPanel.classList.add('active');
                    
                    // Update currentViewCode, currentDataset and overlay URL
                    const label = iframeLabels.get(selectedIndex);
                    currentViewCode = viewCodes[label] || label.toLowerCase();
                    const dataset = iframeDatasets.get(selectedIndex);
                    currentDataset = dataset;
                    updateOverlayUrl(currentViewCode, currentMapParams, currentDataset);
                    
                    // Only reload if iframe is not already synced with current params
                    const currentSyncKey = getSyncKey(currentMapParams);
                    const iframeSyncKey = iframeSynced.get(selectedIndex);
                    
                    if (iframeSyncKey !== currentSyncKey && dataset && currentMapParams.lat && currentMapParams.lon && currentMapParams.zoom) {
                        const newUrl = buildInsarmapsUrl(
                            baseUrl,
                            dataset,
                            currentMapParams.lat,
                            currentMapParams.lon,
                            currentMapParams.zoom,
                            currentMapParams
                        );
                        const iframe = document.getElementById(`iframe${selectedIndex}`);
                        if (iframe) {
                            // Set cooldown to prevent feedback loop
                            lastSyncTime = Date.now();
                            iframe.src = newUrl;
                            iframeSynced.set(selectedIndex, currentSyncKey);
                        }
                    }
                    // If already synced, just show it - no reload needed!
                });
                
                // ===== IFRAME SYNCHRONIZATION =====
                let syncTimeout = null;
                const SYNC_DEBOUNCE_MS = 1500;
                let lastSyncedKey = '';
                
                // Listen for URL updates from any iframe
                window.addEventListener('message', (event) => {
                    if (!event.data || event.data.type !== 'insarmaps-url-update') return;
                    
                    // Ignore messages during cooldown
                    const now = Date.now();
                    if (now - lastSyncTime < SYNC_COOLDOWN_MS) return;
                    
                    if (syncTimeout) clearTimeout(syncTimeout);
                    
                    syncTimeout = setTimeout(() => {
                        const newUrlPath = event.data.url;
                        
                        // Parse path: /start/{lat}/{lon}/{zoom}?params...
                        const pathMatch = newUrlPath.match(/^\/start\/([^\/]+)\/([^\/]+)\/([^?]+)/);
                        if (!pathMatch) return;
                        
                        const [, lat, lon, zoom] = pathMatch;
                        
                        // Parse query parameters
                        const queryStart = newUrlPath.indexOf('?');
                        const params = new URLSearchParams(
                            queryStart >= 0 ? newUrlPath.substring(queryStart) : ''
                        );
                        
                        // Create sync key with all sync-relevant params
                        const syncKey = JSON.stringify({
                            lat, lon, zoom,
                            minScale: params.get('minScale'),
                            maxScale: params.get('maxScale'),
                            startDate: params.get('startDate'),
                            endDate: params.get('endDate'),
                            pixelSize: params.get('pixelSize'),
                            background: params.get('background'),
                            opacity: params.get('opacity')
                        });
                        
                        if (syncKey === lastSyncedKey) return;
                        lastSyncedKey = syncKey;
                        
                        // Update current map params
                        currentMapParams = {
                            lat: lat,
                            lon: lon,
                            zoom: zoom,
                            minScale: params.get('minScale'),
                            maxScale: params.get('maxScale'),
                            startDate: params.get('startDate'),
                            endDate: params.get('endDate'),
                            pixelSize: params.get('pixelSize'),
                            background: params.get('background'),
                            opacity: params.get('opacity')
                        };
                        
                        // Update overlay.html's browser URL
                        updateOverlayUrl(currentViewCode, currentMapParams, currentDataset);
                        
                        // Find sender iframe
                        let senderIndex = -1;
                        for (let i = 0; i < urlsList.length; i++) {
                            const iframe = document.getElementById(`iframe${i}`);
                            if (iframe && event.source === iframe.contentWindow) {
                                senderIndex = i;
                                break;
                            }
                        }
                        
                        // Set cooldown
                        lastSyncTime = Date.now();
                        
                        // Get the sync key for the new params
                        const newSyncKey = getSyncKey(currentMapParams);
                        
                        // Mark sender as synced
                        if (senderIndex >= 0) {
                            iframeSynced.set(senderIndex, newSyncKey);
                        }
                        
                        // Update all OTHER iframes
                        iframeDatasets.forEach((originalDataset, index) => {
                            if (index === senderIndex) return;
                            
                            const newUrl = buildInsarmapsUrl(
                                baseUrl, 
                                originalDataset, 
                                lat, 
                                lon, 
                                zoom, 
                                currentMapParams
                            );
                            const iframe = document.getElementById(`iframe${index}`);
                            if (iframe) {
                                iframe.src = newUrl;
                                // Mark as synced with new params
                                iframeSynced.set(index, newSyncKey);
                            }
                        });
                    }, SYNC_DEBOUNCE_MS);
                });
                // ===== END IFRAME SYNCHRONIZATION =====
            })
            .catch(error => {
                console.error('Error loading insarmaps.log:', error);
                document.getElementById('loading').textContent = 'Error loading insarmaps.log: ' + error.message;
            });
        
        // Load download link dynamically
        fetch('download_commands.txt')
            .then(response => response.text())
            .then(() => {
                const p = document.createElement('p');
                p.style.cssText = 'margin: 20px; font-family: Arial, sans-serif; text-align: center;';
                p.innerHTML = 'Data download: <a href="download_commands.txt" target="_blank">link</a>';
                document.body.appendChild(p);
            })
            .catch(() => {
                console.log('download_commands.txt not found');
            });
    </script>
</body>
</html>
