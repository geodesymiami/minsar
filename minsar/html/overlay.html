<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Insarmaps - Frame Overlay</title>
    <style>
        body {
            margin: 0;
            padding: 10px;
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
        }
        .frame-selector {
            margin-bottom: 10px;
            padding: 10px;
            background-color: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .frame-selector label {
            font-weight: bold;
            font-size: 14px;
            color: #333;
        }
        .frame-selector select {
            padding: 6px 12px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
            flex: 1;
            max-width: 300px;
        }
        .frame-selector select:focus {
            outline: none;
            border-color: #4a90e2;
        }
        .container {
            width: 100%;
            height: calc(100vh - 80px);
            max-width: 100%;
            position: relative;
        }
        .panel {
            background-color: white;
            border: 2px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
            transition: box-shadow 0.2s;
            display: none;
        }
        .panel.active {
            display: block;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.5);
        }
        .panel:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .panel-header {
            background-color: #4a90e2;
            color: white;
            padding: 8px 12px;
            font-size: 14px;
            font-weight: bold;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            height: 38px;
            box-sizing: border-box;
        }
        .panel-header-title {
            flex: 1;
        }
        .panel iframe {
            width: 100%;
            height: calc(100% - 38px);
            border: none;
            display: block;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading insarmaps data...</div>
    <div class="frame-selector" id="frame-selector" style="display:none;">
        <label for="frame-select">Select dataset:</label>
        <select id="frame-select"></select>
    </div>
    <div class="container" id="container"></div>
    
    <script>
        // ===== URL STATE MANAGEMENT =====
        // Map view labels to short codes for URL
        const viewCodes = {
            'Descending': 'desc',
            'Ascending': 'asc',
            'Vertical': 'vert',
            'Horizontal': 'horz'
        };
        const codeToLabel = { 'desc': 'Descending', 'asc': 'Ascending', 'vert': 'Vertical', 'horz': 'Horizontal' };

        // Get URL parameters from overlay.html's URL
        function getOverlayUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                view: params.get('view'),
                lat: params.get('lat'),
                lng: params.get('lng'),
                zoom: params.get('zoom'),
                minScale: params.get('minScale'),
                maxScale: params.get('maxScale'),
                startDate: params.get('startDate'),
                endDate: params.get('endDate'),
                pointLat: params.get('pointLat'),
                pointLon: params.get('pointLon'),
                refPointLat: params.get('refPointLat'),
                refPointLon: params.get('refPointLon'),
                colorscale: params.get('colorscale'),
                pixelSize: params.get('pixelSize'),
                background: params.get('background')
            };
        }

        // Update overlay.html's browser URL with current state
        function updateOverlayUrl(viewCode, mapParams) {
            const params = new URLSearchParams();
            if (viewCode) params.set('view', viewCode);
            if (mapParams.lat) params.set('lat', mapParams.lat);
            if (mapParams.lng) params.set('lng', mapParams.lng);
            if (mapParams.zoom) params.set('zoom', mapParams.zoom);
            if (mapParams.minScale) params.set('minScale', mapParams.minScale);
            if (mapParams.maxScale) params.set('maxScale', mapParams.maxScale);
            if (mapParams.startDate) params.set('startDate', mapParams.startDate);
            if (mapParams.endDate) params.set('endDate', mapParams.endDate);
            if (mapParams.pointLat) params.set('pointLat', mapParams.pointLat);
            if (mapParams.pointLon) params.set('pointLon', mapParams.pointLon);
            if (mapParams.refPointLat) params.set('refPointLat', mapParams.refPointLat);
            if (mapParams.refPointLon) params.set('refPointLon', mapParams.refPointLon);
            if (mapParams.colorscale) params.set('colorscale', mapParams.colorscale);
            if (mapParams.pixelSize) params.set('pixelSize', mapParams.pixelSize);
            if (mapParams.background) params.set('background', mapParams.background);
            
            const newUrl = window.location.pathname + '?' + params.toString();
            window.history.replaceState({}, '', newUrl);
        }

        // Build insarmaps URL with given parameters
        function buildInsarmapsUrl(baseUrl, dataset, lat, lng, zoom, mapParams) {
            const params = new URLSearchParams();
            params.set('flyToDatasetCenter', 'false');
            params.set('startDataset', dataset);
            if (mapParams.minScale) params.set('minScale', mapParams.minScale);
            if (mapParams.maxScale) params.set('maxScale', mapParams.maxScale);
            if (mapParams.startDate) params.set('startDate', mapParams.startDate);
            if (mapParams.endDate) params.set('endDate', mapParams.endDate);
            if (mapParams.pointLat) params.set('pointLat', mapParams.pointLat);
            if (mapParams.pointLon) params.set('pointLon', mapParams.pointLon);
            if (mapParams.refPointLat) params.set('refPointLat', mapParams.refPointLat);
            if (mapParams.refPointLon) params.set('refPointLon', mapParams.refPointLon);
            if (mapParams.colorscale) params.set('colorscale', mapParams.colorscale);
            if (mapParams.pixelSize) params.set('pixelSize', mapParams.pixelSize);
            if (mapParams.background) params.set('background', mapParams.background);
            params.set('hideAttributes', 'true');
            params.set('_t', Date.now());
            
            return `${baseUrl}/start/${lat}/${lng}/${zoom}?${params.toString()}`;
        }

        // Extract lat/lng/zoom from an insarmaps URL
        function parseInsarmapsUrl(url) {
            try {
                const urlObj = new URL(url);
                const pathMatch = urlObj.pathname.match(/\/start\/([^\/]+)\/([^\/]+)\/([^\/]+)/);
                if (pathMatch) {
                    return { lat: pathMatch[1], lng: pathMatch[2], zoom: pathMatch[3] };
                }
            } catch (e) {}
            return null;
        }
        // ===== END URL STATE MANAGEMENT =====

        // Global state
        let iframeDatasets = new Map();  // index -> dataset name
        let iframeLabels = new Map();    // index -> label (Descending, etc.)
        let baseUrl = '';
        let currentViewCode = 'desc';
        let currentMapParams = {};
        let urlsList = [];

        // Parse insarmaps.log and create iframes dynamically
        fetch('insarmaps.log')
            .then(response => response.text())
            .then(data => {
                const lines = data.split('\n');
                const urls = lines
                    .map(line => line.trim())
                    .filter(line => line && (line.startsWith('http://') || line.startsWith('https://')));
                
                if (urls.length === 0) {
                    document.getElementById('loading').textContent = 'No URLs found in insarmaps.log';
                    return;
                }
                
                // Sort URLs by dataset type: desc (0), asc (1), horz (2), vert (3), others (4)
                urls.sort((a, b) => {
                    const getSortKey = (url) => {
                        try {
                            const urlObj = new URL(url);
                            const startDataset = urlObj.searchParams.get('startDataset') || '';
                            const lower = startDataset.toLowerCase();
                            if (lower.includes('desc')) return 0;
                            if (lower.includes('asc')) return 1;
                            if (lower.includes('horz')) return 2;
                            if (lower.includes('vert')) return 3;
                            return 4;
                        } catch (e) {
                            return 5;
                        }
                    };
                    return getSortKey(a) - getSortKey(b);
                });
                
                urlsList = urls;
                
                // Extract labels from URLs
                const getLabel = (url) => {
                    try {
                        const urlObj = new URL(url);
                        const startDataset = urlObj.searchParams.get('startDataset') || '';
                        const lower = startDataset.toLowerCase();
                        if (lower.includes('desc')) return 'Descending';
                        if (lower.includes('asc')) return 'Ascending';
                        if (lower.includes('vert')) return 'Vertical';
                        if (lower.includes('horz')) return 'Horizontal';
                        return startDataset || 'Dataset';
                    } catch (e) {
                        return 'Dataset';
                    }
                };
                
                // Get initial params from overlay.html URL
                const initialParams = getOverlayUrlParams();
                
                // Initialize current map params from overlay URL or first insarmaps URL
                const firstUrlCoords = parseInsarmapsUrl(urls[0]);
                currentMapParams = {
                    lat: initialParams.lat || (firstUrlCoords ? firstUrlCoords.lat : null),
                    lng: initialParams.lng || (firstUrlCoords ? firstUrlCoords.lng : null),
                    zoom: initialParams.zoom || (firstUrlCoords ? firstUrlCoords.zoom : null),
                    minScale: initialParams.minScale,
                    maxScale: initialParams.maxScale,
                    startDate: initialParams.startDate,
                    endDate: initialParams.endDate,
                    pointLat: initialParams.pointLat,
                    pointLon: initialParams.pointLon,
                    refPointLat: initialParams.refPointLat,
                    refPointLon: initialParams.refPointLon,
                    colorscale: initialParams.colorscale,
                    pixelSize: initialParams.pixelSize,
                    background: initialParams.background
                };
                
                // Create panels for each URL
                const container = document.getElementById('container');
                const frameSelect = document.getElementById('frame-select');
                const frameSelector = document.getElementById('frame-selector');
                
                // Determine initial active panel based on URL view param
                let initialActiveIndex = 0;
                
                urls.forEach((url, index) => {
                    try {
                        const urlObj = new URL(url);
                        const dataset = urlObj.searchParams.get('startDataset');
                        iframeDatasets.set(index, dataset);
                        
                        // Extract base URL from first URL
                        if (!baseUrl) {
                            baseUrl = urlObj.origin;
                        }
                    } catch (e) {
                        console.warn('Could not parse URL:', url);
                    }
                    
                    const label = getLabel(url);
                    iframeLabels.set(index, label);
                    const labelCode = viewCodes[label] || label.toLowerCase();
                    
                    // Check if this should be the active panel based on URL param
                    if (initialParams.view && labelCode === initialParams.view) {
                        initialActiveIndex = index;
                        currentViewCode = labelCode;
                    }
                    
                    // Add option to dropdown
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = label;
                    frameSelect.appendChild(option);
                });
                
                // Set default view code if not specified in URL
                if (!initialParams.view) {
                    const firstLabel = iframeLabels.get(0);
                    currentViewCode = viewCodes[firstLabel] || 'desc';
                }
                
                // Create panels with potentially modified URLs
                urls.forEach((url, index) => {
                    // Create panel
                    const panel = document.createElement('div');
                    panel.className = 'panel';
                    panel.id = `panel${index}`;
                    if (index === initialActiveIndex) panel.classList.add('active');
                    
                    // Create header
                    const header = document.createElement('div');
                    header.className = 'panel-header';
                    const title = document.createElement('span');
                    title.className = 'panel-header-title';
                    title.textContent = iframeLabels.get(index);
                    header.appendChild(title);
                    
                    // Build iframe URL - use overlay params if available
                    let iframeSrc = url;
                    const dataset = iframeDatasets.get(index);
                    if (currentMapParams.lat && currentMapParams.lng && currentMapParams.zoom && dataset) {
                        iframeSrc = buildInsarmapsUrl(
                            baseUrl, 
                            dataset, 
                            currentMapParams.lat, 
                            currentMapParams.lng, 
                            currentMapParams.zoom, 
                            currentMapParams
                        );
                    } else {
                        iframeSrc = url + (url.includes('?') ? '&' : '?') + 'hideAttributes=true&_t=' + Date.now();
                    }
                    
                    // Create iframe
                    const iframe = document.createElement('iframe');
                    iframe.id = `iframe${index}`;
                    iframe.title = iframeLabels.get(index);
                    iframe.src = iframeSrc;
                    iframe.setAttribute('allowfullscreen', '');
                    
                    panel.appendChild(header);
                    panel.appendChild(iframe);
                    container.appendChild(panel);
                });
                
                // Show selector and hide loading
                frameSelector.style.display = 'flex';
                document.getElementById('loading').style.display = 'none';
                
                // Set initial dropdown selection
                frameSelect.value = initialActiveIndex.toString();
                
                // Update overlay URL with initial state
                updateOverlayUrl(currentViewCode, currentMapParams);
                
                // Frame selector functionality - update URL when dataset changes
                frameSelect.addEventListener('change', (e) => {
                    const selectedIndex = parseInt(e.target.value);
                    document.querySelectorAll('.panel').forEach(panel => panel.classList.remove('active'));
                    const selectedPanel = document.getElementById(`panel${selectedIndex}`);
                    if (selectedPanel) selectedPanel.classList.add('active');
                    
                    // Update currentViewCode and overlay URL
                    const label = iframeLabels.get(selectedIndex);
                    currentViewCode = viewCodes[label] || label.toLowerCase();
                    updateOverlayUrl(currentViewCode, currentMapParams);
                });
                
                // ===== IFRAME SYNCHRONIZATION =====
                // Debounce timer for sync updates
                let syncTimeout = null;
                const SYNC_DEBOUNCE_MS = 300;
                
                // Listen for URL updates from any iframe (requires insarmaps postMessage support)
                window.addEventListener('message', (event) => {
                    // Validate message structure
                    if (!event.data || event.data.type !== 'insarmaps-url-update') return;
                    
                    // Clear previous pending sync
                    if (syncTimeout) clearTimeout(syncTimeout);
                    
                    // Debounce: wait for user to stop interacting
                    syncTimeout = setTimeout(() => {
                        const newUrlPath = event.data.url;
                        
                        // Parse path: /start/{lat}/{lng}/{zoom}?params...
                        const pathMatch = newUrlPath.match(/^\/start\/([^\/]+)\/([^\/]+)\/([^?]+)/);
                        if (!pathMatch) return;
                        
                        const [, lat, lng, zoom] = pathMatch;
                        
                        // Parse query parameters from insarmaps URL
                        const queryStart = newUrlPath.indexOf('?');
                        const params = new URLSearchParams(
                            queryStart >= 0 ? newUrlPath.substring(queryStart) : ''
                        );
                        
                        // Update current map params
                        currentMapParams = {
                            lat: lat,
                            lng: lng,
                            zoom: zoom,
                            minScale: params.get('minScale'),
                            maxScale: params.get('maxScale'),
                            startDate: params.get('startDate'),
                            endDate: params.get('endDate'),
                            pointLat: params.get('pointLat'),
                            pointLon: params.get('pointLon'),
                            refPointLat: params.get('refPointLat'),
                            refPointLon: params.get('refPointLon'),
                            colorscale: params.get('colorscale'),
                            pixelSize: params.get('pixelSize'),
                            background: params.get('background')
                        };
                        
                        // Update overlay.html's browser URL
                        updateOverlayUrl(currentViewCode, currentMapParams);
                        
                        // Find which iframe sent the message
                        let senderIndex = -1;
                        for (let i = 0; i < urlsList.length; i++) {
                            const iframe = document.getElementById(`iframe${i}`);
                            if (iframe && event.source === iframe.contentWindow) {
                                senderIndex = i;
                                break;
                            }
                        }
                        
                        // Update all OTHER iframes with new coordinates/params, keeping their dataset
                        iframeDatasets.forEach((originalDataset, index) => {
                            if (index === senderIndex) return;  // Don't reload the sender
                            
                            const newUrl = buildInsarmapsUrl(
                                baseUrl, 
                                originalDataset, 
                                lat, 
                                lng, 
                                zoom, 
                                currentMapParams
                            );
                            const iframe = document.getElementById(`iframe${index}`);
                            if (iframe) {
                                iframe.src = newUrl;
                            }
                        });
                    }, SYNC_DEBOUNCE_MS);
                });
                // ===== END IFRAME SYNCHRONIZATION =====
            })
            .catch(error => {
                console.error('Error loading insarmaps.log:', error);
                document.getElementById('loading').textContent = 'Error loading insarmaps.log: ' + error.message;
            });
        
        // Load download link dynamically
        fetch('download_commands.txt')
            .then(response => response.text())
            .then(() => {
                // File exists, add download link
                const p = document.createElement('p');
                p.style.cssText = 'margin: 20px; font-family: Arial, sans-serif; text-align: center;';
                p.innerHTML = 'Data download: <a href="download_commands.txt" target="_blank">link</a>';
                document.body.appendChild(p);
            })
            .catch(() => {
                // File doesn't exist, no download link
                console.log('download_commands.txt not found');
            });
    </script>
</body>
</html>


